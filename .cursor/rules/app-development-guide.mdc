---
description: 
globs: 
alwaysApply: true
---
# NFC LinkCard Express API 開發指南

## 概述

本文檔詳細說明 NFC LinkCard Express 專案中 API 的開發流程、設計模式和最佳實踐。所有的 API 開發都應遵循此指南，以確保代碼一致性、可維護性和安全性。

## API 開發流程

### 1. 需求分析與設計

- **定義資源和關係**：明確 API 操作的資源類型和關係
- **確定端點命名**：使用一致的 RESTful 命名規則
- **規劃請求和響應格式**：包括數據結構、狀態碼和錯誤處理
- **制定安全策略**：確定身份驗證和授權需求

### 2. 實現步驟

```mermaid
graph TD
    A[1. 數據模型定義] --> B[2. DTO 創建]
    B --> C[3. 服務層實現]
    C --> D[4. 控制器實現]
    D --> E[5. 路由配置]
    E --> F[6. 中間件添加]
    F --> G[7. 測試]
```

#### 2.1 數據模型定義 (Prisma Schema)

在 `prisma/schema.prisma` 中定義或更新模型：

```prisma
model User {
  id               String    @id @default(uuid())
  email            String    @unique
  username         String    @unique
  password         String
  is_verified      Boolean   @default(false)
  verification_token String?
  // ... 其他字段
}
```

#### 2.2 DTO 創建

在 `src/dtos` 目錄中創建或更新相應的 DTO：

```typescript
// src/dtos/auth.dto.ts
export class RegisterDto {
    @IsEmail()
    email: string;
    
    @IsString()
    @Length(3, 20)
    username: string;
    
    @IsString()
    @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/)
    password: string;
}
```

#### 2.3 服務層實現

在 `src/services` 目錄中創建或更新相應的服務：

```typescript
// src/services/AuthService.ts
@Service()
export class AuthService {
    constructor(
        private readonly emailService: EmailService,
        private readonly prisma: PrismaClient
    ) {}
    
    async register(registerDto: RegisterDto, res: Response) {
        // 1. 檢查用戶是否已存在
        // 2. 生成驗證 token
        // 3. 創建用戶
        // 4. 發送驗證郵件
        // 5. 返回結果
    }
}
```

#### 2.4 控制器實現

在 `src/controllers` 目錄中創建或更新相應的控制器：

```typescript
// src/controllers/AuthController.ts
@Service()
export class AuthController {
    constructor(
        private readonly emailService: EmailService,
        private readonly userService: UserService,
        private readonly authService: AuthService,
    ) {}
    
    register = async (req: Request, res: Response) => {
        try {
            // 1. 轉換和驗證請求數據
            // 2. 調用服務層處理業務邏輯
            // 3. 格式化並返回響應
        } catch (error) {
            // 處理錯誤
        }
    }
}
```

#### 2.5 路由配置

在 `src/routes` 目錄中創建或更新相應的路由：

```typescript
// src/routes/auth.ts
import { Router } from 'express';
import { Container } from 'typedi';
import { AuthController } from '../controllers/AuthController';

const router = Router();
const authController = Container.get(AuthController);

router.post('/register', authController.register);
router.post('/verify-email', authController.verifyEmail);
router.post('/login', authController.login);

export default router;
```

#### 2.6 中間件添加

根據需要添加中間件，如身份驗證、權限檢查等：

```typescript
// 在路由配置中添加中間件
router.get('/profile', authMiddleware, userController.getProfile);
```

#### 2.7 測試

編寫單元測試和集成測試，確保 API 按預期工作。

### 3. 發布與文檔

- 更新 API 文檔
- 將變更部署到測試環境
- 進行功能驗證
- 部署到生產環境

## API 設計模式與最佳實踐

### 1. RESTful API 設計

| HTTP 方法 | 用途 | 示例 |
|----------|------|------|
| GET | 獲取資源 | `GET /api/users/123` |
| POST | 創建資源 | `POST /api/users` |
| PUT | 全量更新資源 | `PUT /api/users/123` |
| PATCH | 部分更新資源 | `PATCH /api/users/123` |
| DELETE | 刪除資源 | `DELETE /api/users/123` |

### 2. 標準響應格式

所有 API 響應都遵循統一格式：

**成功響應**：
```json
{
    "success": true,
    "data": {
        // 響應數據...
    }
}
```

**錯誤響應**：
```json
{
    "success": false,
    "error": {
        "message": "錯誤消息",
        "code": "ERROR_CODE",
        "details": "詳細錯誤信息"
    }
}
```

### 3. 命名約定

- **URL**: 使用小寫和連字符 (`kebab-case`)，如 `/api/reset-password`
- **資源名**: 使用複數形式，如 `/api/users`
- **查詢參數**: 使用小駝峰命名法 (`camelCase`)，如 `?sortBy=createdAt`
- **HTTP 頭**: 按照標準命名，如 `Authorization`

### 4. 業務邏輯分層

```
控制器層： 處理請求解析和響應格式化
    ↓
服務層： 實現核心業務邏輯
    ↓
數據訪問層： 處理數據庫交互
```

## API 安全性考慮

### 1. 身份驗證與授權

- **JWT 令牌**：放置在 HTTP 頭的 `Authorization` 字段
- **令牌刷新**：實現令牌刷新機制，延長用戶會話
- **權限檢查**：使用中間件驗證用戶權限

### 2. 數據驗證

- 所有請求數據都必須通過 DTO 進行驗證
- 使用 `class-validator` 裝飾器定義驗證規則
- 在控制器層進行驗證，返回詳細的錯誤信息

### 3. 安全防護

- **CORS 保護**：配置適當的跨域資源共享策略
- **速率限制**：防止暴力破解和 DoS 攻擊
- **輸入消毒**：防止 XSS 和 SQL 注入
- **CSRF 保護**：對非 GET 請求實施 CSRF 保護

## 已實現的 API 示例

### 1. 用戶註冊與電子郵件驗證

**註冊流程**：
1. 客戶端提交註冊信息
2. 服務器驗證信息並創建未驗證用戶
3. 生成驗證令牌並發送驗證郵件
4. 用戶點擊郵件中的鏈接完成驗證
5. 服務器驗證令牌，更新用戶狀態，並返回 JWT

**關鍵代碼示例**：

```typescript
// 控制器中的註冊方法
register = async (req: Request, res: Response) => {
    try {
        const registerDto = plainToClass(RegisterDto, req.body);
        const errors = await validate(registerDto);

        if (errors.length > 0) {
            return ApiResponse.error(res, 'Validation error', 'VALIDATION_ERROR', errors, 400);
        }

        const result = await this.authService.register(registerDto, res);
        if ('user' in result) {
            return ApiResponse.success(
                res,
                {
                    message: 'Registration successful. Please check your email to verify your account.',
                },
                201,
            );
        }
        return result;
    } catch (error: unknown) {
        const apiError = error as ApiError;
        return ApiResponse.error(
            res,
            'Registration failed',
            'REGISTER_ERROR',
            apiError.message,
            500,
        );
    }
}
```

### 2. 用戶登入

**登入流程**：
1. 客戶端提交登入信息
2. 服務器驗證信息
3. 生成 JWT 令牌
4. 返回用戶信息和令牌

**關鍵代碼示例**：

```typescript
// 控制器中的登入方法
login = async (req: Request, res: Response) => {
    try {
        const loginDto = plainToClass(LoginDto, req.body);
        const errors = await validate(loginDto);

        if (errors.length > 0) {
            return ApiResponse.error(res, '驗證錯誤', 'VALIDATION_ERROR', errors, 400);
        }

        const result: any = await this.authService.login(loginDto, res);
        if (!result.user) return;

        return ApiResponse.success(res, { user: result.user }, 200, {
            Authorization: `Bearer ${result.token}`,
        });
    } catch (error: unknown) {
        const apiError = error as ApiError;
        return ApiResponse.error(res, '登入失敗', 'LOGIN_ERROR', apiError.message, 500);
    }
};
```

## 常見問題與解決方案

### 1. 處理異步操作

使用 async/await 處理異步操作，避免回調地獄：

```typescript
async function example() {
    try {
        const result = await someAsyncOperation();
        return result;
    } catch (error) {
        // 處理錯誤
    }
}
```

### 2. 錯誤處理最佳實踐

- 使用全局錯誤處理中間件捕獲未處理的錯誤
- 在服務層拋出有意義的業務錯誤
- 在控制器層捕獲錯誤並格式化響應

```typescript
// 全局錯誤處理中間件
export const errorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {
    console.error(err);
    
    // 處理不同類型的錯誤
    if (err instanceof ApiError) {
        return ApiResponse.error(res, err.message, err.code, null, err.status);
    }
    
    // 處理未知錯誤
    return ApiResponse.error(res, 'Internal Server Error', 'SERVER_ERROR', null, 500);
};
```

### 3. 處理文件上傳

使用 multer 處理文件上傳，並在服務層處理存儲：

```typescript
// 設置 multer
const storage = multer.memoryStorage();
const upload = multer({ 
    storage, 
    limits: { fileSize: 5 * 1024 * 1024 } // 5MB
});

// 路由配置
router.post('/upload-avatar', authMiddleware, upload.single('avatar'), userController.uploadAvatar);
```

## 測試指南

### 1. 單元測試

專注於測試單個功能或方法，模擬依賴項：

```typescript
// 服務層測試示例
describe('AuthService', () => {
    let authService: AuthService;
    let prisma: PrismaClient;
    
    beforeEach(() => {
        prisma = mock(PrismaClient);
        authService = new AuthService(prisma);
    });
    
    it('should register a new user', async () => {
        // 測試代碼...
    });
});
```

### 2. 集成測試

測試多個組件的協作，使用測試數據庫：

```typescript
// API 集成測試示例
describe('Auth API', () => {
    it('should register a new user', async () => {
        const response = await request(app)
            .post('/api/auth/register')
            .send({
                email: 'test@example.com',
                username: 'testuser',
                password: 'Password123'
            });
        
        expect(response.status).toBe(201);
        expect(response.body.success).toBe(true);
    });
});
```

### 3. Postman 測試

使用 Postman 進行手動測試和調試：

1. 創建環境變量存儲 API URL 和令牌
2. 使用預處理腳本自動處理認證
3. 使用測試腳本驗證響應

## 性能優化

### 1. 數據庫查詢優化

- 使用適當的索引
- 只選擇必要的字段
- 使用批量操作代替循環查詢

```typescript
// 優化查詢示例
const users = await prisma.user.findMany({
    where: { is_verified: true },
    select: { id: true, email: true, username: true },
    take: 10,
    skip: page * 10
});
```

### 2. 緩存策略

- 對頻繁訪問的數據實施緩存
- 使用合適的緩存失效策略
- 考慮使用 Redis 等分佈式緩存

### 3. 批量處理

- 實現批量處理 API
- 使用事務確保數據一致性
- 考慮使用消息隊列處理大量異步任務

## 版本控制

為 API 實施版本控制，避免破壞性變更影響現有客戶端：

- **URL 版本控制**：如 `/api/v1/users`
- **HTTP 頭版本控制**：使用 `Accept` 頭指定版本
- **查詢參數版本控制**：如 `/api/users?version=1`

## 文檔和示例

維護全面的 API 文檔，包括：

- 端點描述和用途
- 請求和響應格式
- 身份驗證要求
- 錯誤碼和處理
- 示例請求和響應

## 結論

遵循本指南開發 API 將確保代碼的一致性、可維護性和安全性。定期回顧和更新本指南，以反映最新的最佳實踐和經驗教訓。 